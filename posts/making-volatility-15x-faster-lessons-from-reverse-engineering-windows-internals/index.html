<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals | Area51</title>
<meta name=keywords content><meta name=description content="Quick TL;DR
By locating the kernel base address from PROCESSOR_START_BLOCK rather than scanning for KDBG, I reduced Volatility&rsquo;s analysis time from ~15 seconds to about a second on a 32GB RAM sample.
See the code that was merged into Volatility.
Important: This method works only on x64 systems with no virtualization. Otherwise, we gracefully fall back to KDBG scanning.
Introduction and summary
Volatility and Memprocfs are two tools for Memory Forensics, but they&rsquo;re implemented differently.
I noticed that Memprocfs parses the RAM file almost instantaneously while Volatility takes longer to analyse the file.
So, I&rsquo;ve conducted a test:"><meta name=author content="Daniel Davidov"><link rel=canonical href=https://danking555.github.io/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://danking555.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://danking555.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://danking555.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://danking555.github.io/apple-touch-icon.png><link rel=mask-icon href=https://danking555.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://danking555.github.io/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://danking555.github.io/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/"><meta property="og:site_name" content="Area51"><meta property="og:title" content="Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals"><meta property="og:description" content="Quick TL;DR By locating the kernel base address from PROCESSOR_START_BLOCK rather than scanning for KDBG, I reduced Volatility’s analysis time from ~15 seconds to about a second on a 32GB RAM sample.
See the code that was merged into Volatility.
Important: This method works only on x64 systems with no virtualization. Otherwise, we gracefully fall back to KDBG scanning.
Introduction and summary Volatility and Memprocfs are two tools for Memory Forensics, but they’re implemented differently. I noticed that Memprocfs parses the RAM file almost instantaneously while Volatility takes longer to analyse the file. So, I’ve conducted a test:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-26T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals"><meta name=twitter:description content="Quick TL;DR
By locating the kernel base address from PROCESSOR_START_BLOCK rather than scanning for KDBG, I reduced Volatility&rsquo;s analysis time from ~15 seconds to about a second on a 32GB RAM sample.
See the code that was merged into Volatility.
Important: This method works only on x64 systems with no virtualization. Otherwise, we gracefully fall back to KDBG scanning.
Introduction and summary
Volatility and Memprocfs are two tools for Memory Forensics, but they&rsquo;re implemented differently.
I noticed that Memprocfs parses the RAM file almost instantaneously while Volatility takes longer to analyse the file.
So, I&rsquo;ve conducted a test:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://danking555.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals","item":"https://danking555.github.io/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals","name":"Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals","description":"Quick TL;DR By locating the kernel base address from PROCESSOR_START_BLOCK rather than scanning for KDBG, I reduced Volatility\u0026rsquo;s analysis time from ~15 seconds to about a second on a 32GB RAM sample.\nSee the code that was merged into Volatility.\nImportant: This method works only on x64 systems with no virtualization. Otherwise, we gracefully fall back to KDBG scanning.\nIntroduction and summary Volatility and Memprocfs are two tools for Memory Forensics, but they\u0026rsquo;re implemented differently. I noticed that Memprocfs parses the RAM file almost instantaneously while Volatility takes longer to analyse the file. So, I\u0026rsquo;ve conducted a test:\n","keywords":[],"articleBody":"Quick TL;DR By locating the kernel base address from PROCESSOR_START_BLOCK rather than scanning for KDBG, I reduced Volatility’s analysis time from ~15 seconds to about a second on a 32GB RAM sample.\nSee the code that was merged into Volatility.\nImportant: This method works only on x64 systems with no virtualization. Otherwise, we gracefully fall back to KDBG scanning.\nIntroduction and summary Volatility and Memprocfs are two tools for Memory Forensics, but they’re implemented differently. I noticed that Memprocfs parses the RAM file almost instantaneously while Volatility takes longer to analyse the file. So, I’ve conducted a test:\nI’ve extracted the RAM from my 32GB system using Winpmem. I’ve ran the pslist plugin of Volatility3 twice and started a timer each time. The first time took 51 seconds - the download of ntoskrnl symbol files took time. The second time took 15 seconds. I’ve ran Memprocfs on the same RAM file, entered the folder that show the processes list. The process list showed up immediately-after about a second. During Incident Response fast processing times of artifacts is crucial. Therefore, I decided to Reverse Engineer the tools to understand how they work and how I can improve Volatility analysis speed.\nAt first, I assumed that Memprocfs is faster because it’s built in C, meanwhile Volatility is built in Python. However, during the Reverse Engineering process I learned the algorithm used by Memprocfs and implemented it inside Volatility. After the changes I’ve made, I’ve conducted a similar test on the same aforementioned 32GB RAM file.\nThe first time took 32 seconds - all symbols of ntoskrnl were downloaded. The second time took about a second. The new algorithm is based of an undocumented structure called PROCESSOR_START_BLOCK that exists only on x64 bit systems with no virtualization and no emulation.\nAdditionally, it exists in the first 1MB of physical memory and has a well defined signature. On the other hand, the previous algorithm was based on heuristics of scanning for the KDBG structure, not necessarily existing at the beginning of the RAM file. with my new implementation, if Volatility is running against memory from x32 machine, a virtual machine or emulated machine, the algorithm will gracefully fall to the KDBG method. You can see the changes I’ve made in the merged PR inside Volatility. During the Reverse Engineering process I’ve decided to learn and understand how the algorithm works by reimplementing the process list extraction in Python. It is only for my learning purposes and should not be used in production! However, you can benefit from the newly implemented feature inside Volatility! :)\nTechnical overview During the debug process, I noticed that the \"KDBG\" scan takes most of the time. How do I know that? Let’s start the Reverse Engineering process.\nVolatility3 Reverse Engineering To begin analysing the memory we need to get it first. What I like to do is to run Memprocfs using the command line memprocfs -device pmem which mounts a new Virtual File System as drive M:, having the RAM file in M:\\memory.pmem. That way, I’ll be able to consult the information from live memory parsed by memprocfs. So to test Volatility3 I specified the following command line in the Pycharm debugger: python vol.py -f M:\\memory.pmem windows.pslist.PsList. After running, a lot of debugging prints started to show up in the console, indicating that the specified memory file is scanned, and it took a lot of time. So, I’ve decided to understand what is the function that is responsible for the scan by sending an interrupt Ctrl+C that will make the python console print the call stack. And indeed, you can see in the following snippet that the code is “stuck” in data = self._file.read(length).\nFollowing the call stack in the snippet, we see that a function that’s called self.determine_valid_kernel calls to valid_kernel = method(self, context, vlayer, progress_callback) which eventually calls method_kdbg_offset.\nLet’s dig in. The aforementioned function \"determine_valid_kernel\" iterates over a list of methods that try to detect “a valid kernel” (assigned to variable valid_kernel).\nvalid_kernel: Optional[ValidKernelType] = None for virtual_layer_name in potential_layers: vlayer = context.layers.get(virtual_layer_name, None) if isinstance(vlayer, layers.intel.Intel): for method in self.methods: valid_kernel = method(self, context, vlayer, progress_callback) if valid_kernel: break if not valid_kernel: vollog.info(\"No suitable kernels found during pdbscan\") return valid_kernel ... ... ... # List of methods to be run, in order, to determine the valid kernels methods = [ method_kdbg_offset, method_module_offset, method_fixed_mapping, method_slow_scan, ] So if, for example we implement our own method to populate the variable valid_kernel, method_kdbg_offset won’t be called and the whole process should be much faster.\nWait, but wait, what should \"valid_kernel\" structure contain?\nIf we continue to analyze the code stack and the code statically we’ll see that determine_valid_kernel calls to method_kdbg_offset which calls to _method_offset(context, vlayer, b'KDBG', 8, progress_callback) that essentialy:\nScans for b'KDBG' bytes (_KDDEBUGGER_DATA64-\u003eOwnerTag) - a process which takes a lot of time. Determines the kernel base from the structure by reading the field _KDDEBUGGER_DATA64-\u003eKernBase. Calls to valid_kernel = self.check_kernel_offset(context, vlayer, address, progress_callback) where address is the previously kernel base. In the snippet below you can see the contents of the valid_kernel variable after it’s populated. In a nutshell it includes:\nthe kernel base offset in virtual memory. The name of the pdb file ntkrnlmp.pdb for the specific kernel version. The offset of the aformentioned name. The GUID that’s used to download the pdb file. So now we know what is the main “time blocker” and how theoretically we can make the program run faster. We should find the kernel base address and pass it to check_kernel_offset which initializes the variable valid_kernel. We are ready to deep dive into how Memprocfs extracts the kernel base offset.\nMemprocfs Reverse Engineering Before we list the operations that Memprocfs does to find the relevant data about the kernel, let’s explain some theory. Memprocfs relies on “the most undocumented structure” that Alex Ionescu says ([in his talk][3]) that he has seen his entire reverse engineering life - the Low Stub. The Low Stub is a tiny little piece of 16 bit code that still lives in 64 bit Windows and it’s used in two cases:\nWhen you’re booting up your processors, it starts in 16 bit Real Mode, moves to 32 bit Protected Mode by the code in Low Stub and then 64 bit Long Mode. When machine returns from sleep, it starts in 16 bit Real Mode first. The Low Stub handles the transition to Protected mode, etc.. Because of the allocation policies on modern hardware, the Low Stub is going to be at 0x1000 most of the times. On some PIC systems with a setting “Discard Low Memory” in the BIOS disabled, the Low Stub won’t be at address 0x1000, but rather 0x2000, 0x3000, etc.. The Low Stub is not only code, but actually the PROCESSOR_START_BLOCK structure, which has alot of fields, one of them called ProcessorState of type KPROCESSOR_STATE, which has Symbols and highly documented. The exciting news is the field Cr3 inside KPROCESSOR_STATE, which holds the address of the DTB (Directory Table Base) AKA, the page tables that can be used to translate virtual addresses to physical addresses.\nFor more information, here’s the talk by Alex Ionescu, start at 43:36 and here are the slides, slides 46-49. For more information about the structures mentioned above see the following reference that seems to be a leak of Windows NT. So basically the process of locating the kernel base and extracting the processes list in Memprocfs goes like this:\nIterate the first 1MB of physical memory, starting from the second page (0x1000). In each iteration, after some performed guard checks (that I document in my code), use the PROCESSOR_START_BLOCK fields offsets to extract relevant data: read the value at offset 0xa0, locating cr3 (pointing at the DTB/PML4). Additionally, in each iteration, read the value at offset 0x70, locating an address we’ll call “kernel_hint” which is an approximate location of the Kernel base. Scans for the location of ntoskrnl PE in 32mb address range beggining from “kernel_hint”, scanning in 2MB chunks. After the scan is finished, it has the offset of the kernel base.\nBut for those of you who are curious, here’s the process list location and initialization process: Extract the address of the exported function \"PsInitialSystemProcess\" from the kernel image in memory. The exported function contains the location of the first \"_EPROCESS\" object. Iterate over the list, applying fuzzing mechanisms to understand the offsets of fields even without symbols. In the snippet below, which is taken from Memprocfs, you can see the loop that iterates the first 1MB of physical memory, starting from the second page (0x1000):\nSo now that we know the algorithm of Memprocfs, let’s implement our own function.\nLet’s call it method_low_stub_offset and put it in the head of the list, the kernel image base detection should be much faster. And, it should not get to the function method_kdbg_offset which blocks, because it scans for the KDBG bytes. The new method should return a \"valid_kernel\" structure.\nSo essentialy, our new method will try to locate the kernel base via x64 Low Stub in lower 1MB starting from second page (4KB). If “Discard Low Memory” setting is disabled in BIOS, the Low Stub may be at the third/fourth or further pages. During the scan a few guard checks are implemented. The code is well documented so I’ll not repeat, but note how I validated the offsets of the fields. I’ve replicated the structures described in this documentation of _PROCESSOR_START_BLOCK and wrote the following code that prints the offset of the given field within the structure:\nvoid print_diff(ULONG64 field_address, ULONG64 base_address) { printf(\"%d:%x\\n\", field_address - base_address, field_address - base_address); } I’ve put all the constant offsets and signatures well documented here.\nBasically the algorithm as the same as previously mentioned. The implemented guard statements are similar to those in Memprocfs except the third:\nThe first 8 bytes of PROCESSOR_START_BLOCK \u0026 0xFFFFFFFFFFFF00FF expected signature for validation is checked: 0x00000001000600E9. It’s constructed from: a. The block starts with a jmp instruction to the end of the block:\nPROCESSOR_START_BLOCK-\u003eJmp-\u003eOpCode = 0xe9 (jmp opcode), of type UCHAR PROCESSOR_START_BLOCK-\u003eJmp-\u003eOffset = 0x6XX, of type USHORT b. A Completion flag is set to non-zero when the target processor has started: PROCESSOR_START_BLOCK-\u003eCompletionFlag = 0x1, of type ULONG\nCompare previously observed valid page table address that’s stored in vlayer._initial_entry with PROCESSOR_START_BLOCK-\u003eProcessorState-\u003eSpecialRegisters-\u003eCr3 which was observed to be an invalid page address, so add 1 (to make it valid too).\nPROCESSOR_START_BLOCK-\u003eLmTarget \u0026 0x3 should be 0, meaning the page entry for the kernel entry should be invalid(1st bit of address) and not readable/writable(2nd bit of address).\nClosing Thoughts Hope you enjoyed reading this as much as I enjoyed implementing it and the community will benefit from this contribution. Special thanks to the creators and maintainers of the Volatility project and to Ulf Frisk, the creator of Memprocfs.\nAlways ask yourself how you can make things run better and be curious how things work, that’s how I learned a lot from this work.\nIf you have any questions feel free to reach me at danieldavidov555@proton.me.\n","wordCount":"1837","inLanguage":"en","datePublished":"2025-01-26T00:00:00Z","dateModified":"2025-01-26T00:00:00Z","author":{"@type":"Person","name":"Daniel Davidov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://danking555.github.io/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/"},"publisher":{"@type":"Organization","name":"Area51","logo":{"@type":"ImageObject","url":"https://danking555.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://danking555.github.io/ accesskey=h title="Area51 (Alt + H)">Area51</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://danking555.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://danking555.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://danking555.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals</h1><div class=post-meta><span title='2025-01-26 00:00:00 +0000 UTC'>January 26, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1837 words&nbsp;·&nbsp;Daniel Davidov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#quick-tldr>Quick TL;DR</a></li><li><a href=#introduction-and-summary>Introduction and summary</a></li><li><a href=#technical-overview>Technical overview</a><ul><li><a href=#volatility3-reverse-engineering>Volatility3 Reverse Engineering</a></li><li><a href=#memprocfs-reverse-engineering>Memprocfs Reverse Engineering</a></li></ul></li><li><a href=#closing-thoughts>Closing Thoughts</a></li></ul></nav></div></details></div><div class=post-content><h2 id=quick-tldr>Quick TL;DR<a hidden class=anchor aria-hidden=true href=#quick-tldr>#</a></h2><p>By locating the kernel base address from <code>PROCESSOR_START_BLOCK</code> rather than scanning for <code>KDBG</code>, I reduced Volatility&rsquo;s analysis time from <strong>~15 seconds to about a second</strong> on a 32GB RAM sample.<br><a href=https://github.com/volatilityfoundation/volatility3/pull/1566>See the code that was merged into Volatility</a>.</p><p>Important: This method works only on x64 systems with no virtualization. Otherwise, we gracefully fall back to <code>KDBG</code> scanning.</p><h2 id=introduction-and-summary>Introduction and summary<a hidden class=anchor aria-hidden=true href=#introduction-and-summary>#</a></h2><p>Volatility and Memprocfs are two tools for Memory Forensics, but they&rsquo;re implemented differently.
I noticed that Memprocfs parses the RAM file almost instantaneously while Volatility takes longer to analyse the file.
So, I&rsquo;ve conducted a test:</p><ol><li>I&rsquo;ve extracted the RAM from my 32GB system using Winpmem.</li><li>I&rsquo;ve ran the pslist plugin of Volatility3 twice and started a timer each time.<ul><li>The first time took <strong>51 seconds</strong> - the download of ntoskrnl symbol files took time.</li><li>The second time took <strong>15 seconds</strong>.</li></ul></li><li>I&rsquo;ve ran Memprocfs on the same RAM file, entered the folder that show the processes list. The process list showed up immediately-after <strong>about a second</strong>.</li></ol><p>During Incident Response fast processing times of artifacts is crucial. Therefore, I decided to Reverse Engineer the tools to understand how they work and how I can improve Volatility analysis speed.</p><p>At first, I assumed that Memprocfs is faster because it&rsquo;s built in C, meanwhile Volatility is built in Python.
However, during the Reverse Engineering process I learned the algorithm used by Memprocfs and implemented it inside Volatility.
After the changes I&rsquo;ve made, I&rsquo;ve conducted a similar test on the same aforementioned 32GB RAM file.</p><ol><li>The first time took <strong>32 seconds</strong> - all symbols of ntoskrnl were downloaded.</li><li>The second time took <strong>about a second</strong>.</li></ol><p>The new algorithm is based of an undocumented structure called <code>PROCESSOR_START_BLOCK</code> that exists only on x64 bit systems with no virtualization and no emulation.<br>Additionally, it exists in the first <strong>1MB</strong> of physical memory and has a well defined signature.
On the other hand, the previous algorithm was based on heuristics of scanning for the <code>KDBG</code> structure, not necessarily existing at the beginning of the RAM file.
with my new implementation, if Volatility is running against memory from x32 machine, a virtual machine or emulated machine, the algorithm will gracefully fall to the <code>KDBG</code> method.
You can see the changes I&rsquo;ve made in the <a href=https://github.com/volatilityfoundation/volatility3/pull/1566>merged PR inside Volatility</a>.
During the Reverse Engineering process I&rsquo;ve decided to learn and understand how the algorithm works by <a href=https://github.com/Danking555/Rampy>reimplementing the process list extraction in Python</a>.
It is only for my learning purposes and <strong>should not</strong> be used in production!
However, you can benefit from the newly implemented feature inside Volatility! :)</p><h2 id=technical-overview>Technical overview<a hidden class=anchor aria-hidden=true href=#technical-overview>#</a></h2><p><strong>During the debug process, I noticed that the <em><code>"KDBG"</code></em> scan takes most of the time.</strong>
How do I know that? Let&rsquo;s start the Reverse Engineering process.</p><h3 id=volatility3-reverse-engineering>Volatility3 Reverse Engineering<a hidden class=anchor aria-hidden=true href=#volatility3-reverse-engineering>#</a></h3><p>To begin analysing the memory we need to get it first. What I like to do is to run <a href=https://github.com/ufrisk/MemProcFS><code>Memprocfs</code></a> using the command line <code>memprocfs -device pmem</code> which mounts a new Virtual File System as drive <code>M:</code>, having the RAM file in <code>M:\memory.pmem</code>.
That way, I&rsquo;ll be able to consult the information from live memory parsed by <code>memprocfs</code>.
So to test <code>Volatility3</code> I specified the following command line in the <code>Pycharm</code> debugger: <code>python vol.py -f M:\memory.pmem windows.pslist.PsList</code>.
After running, a lot of debugging prints started to show up in the console, indicating that the specified memory file is scanned, and it took a lot of time.
So, I&rsquo;ve decided to understand what is the function that is responsible for the scan by sending an interrupt <code>Ctrl+C</code> that will make the python console print the call stack.
And indeed, you can see in the following snippet that the code is &ldquo;stuck&rdquo; in <code>data = self._file.read(length)</code>.</p><p><img loading=lazy src=/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/images/1determine_scan_blocker.png></p><p>Following the call stack in the snippet, we see that a function that&rsquo;s called <code>self.determine_valid_kernel</code> calls to <code>valid_kernel = method(self, context, vlayer, progress_callback)</code> which eventually calls <code>method_kdbg_offset</code>.</p><p>Let&rsquo;s dig in. The aforementioned function <code>"determine_valid_kernel"</code> iterates over a list of methods that try to detect &ldquo;a valid kernel&rdquo; (assigned to variable <code>valid_kernel</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    valid_kernel: Optional[ValidKernelType] <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> virtual_layer_name <span style=color:#f92672>in</span> potential_layers:
</span></span><span style=display:flex><span>            vlayer <span style=color:#f92672>=</span> context<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>get(virtual_layer_name, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> isinstance(vlayer, layers<span style=color:#f92672>.</span>intel<span style=color:#f92672>.</span>Intel):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> method <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>methods:
</span></span><span style=display:flex><span>                    valid_kernel <span style=color:#f92672>=</span> method(self, context, vlayer, progress_callback)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> valid_kernel:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> valid_kernel:
</span></span><span style=display:flex><span>            vollog<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;No suitable kernels found during pdbscan&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> valid_kernel
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># List of methods to be run, in order, to determine the valid kernels</span>
</span></span><span style=display:flex><span>    methods <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        method_kdbg_offset,
</span></span><span style=display:flex><span>        method_module_offset,
</span></span><span style=display:flex><span>        method_fixed_mapping,
</span></span><span style=display:flex><span>        method_slow_scan,
</span></span><span style=display:flex><span>    ]
</span></span></code></pre></div><p>So if, for example we implement our own method to populate the variable <code>valid_kernel</code>, <code>method_kdbg_offset</code> won&rsquo;t be called and the whole process should be much faster.</p><p>Wait, but wait, what should <code>"valid_kernel"</code> structure contain?</p><p>If we continue to analyze the code stack and the code statically we&rsquo;ll see that <code>determine_valid_kernel</code> calls to <code>method_kdbg_offset</code> which calls to <code>_method_offset(context, vlayer, b'KDBG', 8, progress_callback)</code> that essentialy:</p><ol><li>Scans for <code>b'KDBG'</code> bytes (<code>_KDDEBUGGER_DATA64->OwnerTag</code>) - a process which takes a lot of time.</li><li>Determines the kernel base from the structure by reading the field <code>_KDDEBUGGER_DATA64->KernBase</code>.</li><li>Calls to <code>valid_kernel = self.check_kernel_offset(context, vlayer, address, progress_callback)</code> where <code>address</code> is the previously kernel base.</li></ol><p>In the snippet below you can see the contents of the <code>valid_kernel</code> variable after it&rsquo;s populated.
In a nutshell it includes:</p><ol><li>the kernel base offset in virtual memory.</li><li>The name of the pdb file <code>ntkrnlmp.pdb</code> for the specific kernel version.</li><li>The offset of the aformentioned name.</li><li>The GUID that&rsquo;s used to download the pdb file.</li></ol><p><img loading=lazy src=/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/images/2valid_kernel.png></p><p>So now we know what is the main &ldquo;time blocker&rdquo; and how theoretically we can make the program run faster.
We should find the kernel base address and pass it to <code>check_kernel_offset</code> which initializes the variable <code>valid_kernel</code>.
We are ready to deep dive into how Memprocfs extracts the kernel base offset.</p><h3 id=memprocfs-reverse-engineering>Memprocfs Reverse Engineering<a hidden class=anchor aria-hidden=true href=#memprocfs-reverse-engineering>#</a></h3><p>Before we list the operations that Memprocfs does to find the relevant data about the kernel, let&rsquo;s explain some theory.
Memprocfs relies on &ldquo;the most undocumented structure&rdquo; that Alex Ionescu says ([in his talk][3]) that he has seen his entire reverse engineering life - the <code>Low Stub</code>.
The <code>Low Stub</code> is a tiny little piece of 16 bit code that still lives in 64 bit Windows and it&rsquo;s used in two cases:</p><ol><li>When you&rsquo;re booting up your processors, it starts in 16 bit Real Mode, moves to 32 bit Protected Mode by the code in <code>Low Stub</code> and then 64 bit Long Mode.</li><li>When machine returns from sleep, it starts in 16 bit Real Mode first. The <code>Low Stub</code> handles the transition to Protected mode, etc..</li></ol><p>Because of the allocation policies on modern hardware, the <code>Low Stub</code> is going to be at 0x1000 most of the times.
On some PIC systems with a setting &ldquo;Discard Low Memory&rdquo; in the BIOS disabled, the <code>Low Stub</code> won&rsquo;t be at address 0x1000, but rather 0x2000, 0x3000, etc..
The <code>Low Stub</code> is not only code, but actually the <code>PROCESSOR_START_BLOCK</code> structure, which has alot of fields, one of them called <code>ProcessorState</code> of type <code>KPROCESSOR_STATE</code>, which has Symbols and highly documented.
The exciting news is the field <code>Cr3</code> inside <code>KPROCESSOR_STATE</code>, which holds the address of the <code>DTB (Directory Table Base)</code> AKA, the page tables that can be used to translate virtual addresses to physical addresses.</p><ul><li>For more information, here&rsquo;s <a href="https://www.youtube.com/watch?v=_ShCSth6dWM">the talk by Alex Ionescu</a>, start at 43:36 and <a href=http://publications.alex-ionescu.com/Recon/ReconBru%202017%20-%20Getting%20Physical%20with%20USB%20Type-C,%20Windows%2010%20RAM%20Forensics%20and%20UEFI%20Attacks.pdf>here are the slides</a>, slides 46-49.</li></ul><ul><li>For more information about the structures mentioned above see the following reference that seems to be <a href=https://github.com/mic101/windows/blob/master/WRK-v1.2/base/ntos/inc/amd64.h#L3334>a leak of Windows NT</a>.</li></ul><p><img loading=lazy src=/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/images/3cr3.png>
<img loading=lazy src=/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/images/4processor_start_block.png></p><p><strong>So basically the process of locating the kernel base and extracting the processes list in Memprocfs goes like this:</strong></p><ol><li>Iterate the first 1MB of physical memory, starting from the second page (0x1000).</li><li>In each iteration, after some performed guard checks (that I document in my code), use the <code>PROCESSOR_START_BLOCK</code> fields offsets to extract relevant data:</li><li>read the value at offset 0xa0, locating cr3 (pointing at the DTB/PML4).</li><li>Additionally, in each iteration, read the value at offset 0x70, locating an address we&rsquo;ll call &ldquo;kernel_hint&rdquo; which is an approximate location of the Kernel base.</li><li>Scans for the location of ntoskrnl PE in 32mb address range beggining from &ldquo;kernel_hint&rdquo;, scanning in 2MB chunks.
After the scan is finished, it has the <strong>offset of the kernel base</strong>.<br>But for those of you who are curious, here&rsquo;s the process list location and initialization process:</li><li>Extract the address of the exported function <code>"PsInitialSystemProcess"</code> from the kernel image in memory.</li><li>The exported function contains the location of the first <em><code>"_EPROCESS"</code></em> object.</li><li>Iterate over the list, applying fuzzing mechanisms to understand the offsets of fields even without symbols.</li></ol><p>In the snippet below, which is taken from <code>Memprocfs</code>, you can see the loop that iterates the first 1MB of physical memory, starting from the second page (0x1000):</p><p><img loading=lazy src=/posts/making-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals/images/5memprocfs_find_low_stub.png></p><p>So now that we know the algorithm of Memprocfs, let&rsquo;s implement our own function.<br>Let&rsquo;s call it <code>method_low_stub_offset</code> and put it in the head of the list, the kernel image base detection should be much faster. And, it should not get to the function <code>method_kdbg_offset</code> which blocks, because it scans for the <code>KDBG</code> bytes.
The new method should return a <code>"valid_kernel"</code> structure.</p><p>So essentialy, our new method will try to locate the kernel base via x64 Low Stub in lower 1MB starting from second page (4KB).
If &ldquo;Discard Low Memory&rdquo; setting is disabled in BIOS, the Low Stub may be at the third/fourth or further pages.
During the scan a few guard checks are implemented. The code is well documented so I&rsquo;ll not repeat, but note how I validated the offsets of the fields. I&rsquo;ve replicated the structures described in <a href=https://github.com/mic101/windows/blob/master/WRK-v1.2/base/ntos/inc/amd64.h#L3334>this documentation of <code>_PROCESSOR_START_BLOCK</code></a> and wrote the following code that prints the offset of the given field within the structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_diff</span>(ULONG64 field_address, ULONG64 base_address) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d:%x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, field_address <span style=color:#f92672>-</span> base_address, field_address <span style=color:#f92672>-</span> base_address);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ve put all the constant offsets and signatures well documented <a href=https://github.com/volatilityfoundation/volatility3/blob/develop/volatility3/framework/constants/windows/__init__.py>here</a>.</p><p>Basically the algorithm as the same as previously mentioned.
The implemented guard statements are similar to those in <code>Memprocfs</code> except the third:</p><ol><li><p>The first 8 bytes of PROCESSOR_START_BLOCK & 0xFFFFFFFFFFFF00FF expected signature for validation is checked: 0x00000001000600E9. It&rsquo;s constructed from:
a. The block starts with a jmp instruction to the end of the block:</p><ul><li>PROCESSOR_START_BLOCK->Jmp->OpCode = 0xe9 (jmp opcode), of type UCHAR</li><li>PROCESSOR_START_BLOCK->Jmp->Offset = 0x6XX, of type USHORT</li></ul><p>b. A Completion flag is set to non-zero when the target processor has started:
PROCESSOR_START_BLOCK->CompletionFlag = 0x1, of type ULONG</p></li><li><p>Compare previously observed valid page table address that&rsquo;s stored in <code>vlayer._initial_entry</code> with <code>PROCESSOR_START_BLOCK->ProcessorState->SpecialRegisters->Cr3</code> which was observed to be an invalid page address, so add 1 (to make it valid too).</p></li><li><p><code>PROCESSOR_START_BLOCK->LmTarget & 0x3</code> should be 0, meaning the page entry for the kernel entry should be invalid(1st bit of address) and not readable/writable(2nd bit of address).</p></li></ol><h2 id=closing-thoughts>Closing Thoughts<a hidden class=anchor aria-hidden=true href=#closing-thoughts>#</a></h2><p>Hope you enjoyed reading this as much as I enjoyed implementing it and the community will benefit from this contribution.
Special thanks to the creators and maintainers of the Volatility project and to Ulf Frisk, the creator of Memprocfs.<br>Always ask yourself how you can make things run better and be curious how things work, that&rsquo;s how I learned a lot from this work.<br>If you have any questions feel free to reach me at <code>danieldavidov555@proton.me</code>.</p></div><footer class=post-footer><ul class=post-tags></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals on x" href="https://x.com/intent/tweet/?text=Making%20Volatility%2015x%20Faster%3a%20Lessons%20from%20Reverse%20Engineering%20Windows%20Internals&amp;url=https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f&amp;title=Making%20Volatility%2015x%20Faster%3a%20Lessons%20from%20Reverse%20Engineering%20Windows%20Internals&amp;summary=Making%20Volatility%2015x%20Faster%3a%20Lessons%20from%20Reverse%20Engineering%20Windows%20Internals&amp;source=https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f&title=Making%20Volatility%2015x%20Faster%3a%20Lessons%20from%20Reverse%20Engineering%20Windows%20Internals"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals on whatsapp" href="https://api.whatsapp.com/send?text=Making%20Volatility%2015x%20Faster%3a%20Lessons%20from%20Reverse%20Engineering%20Windows%20Internals%20-%20https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals on telegram" href="https://telegram.me/share/url?text=Making%20Volatility%2015x%20Faster%3a%20Lessons%20from%20Reverse%20Engineering%20Windows%20Internals&amp;url=https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Making Volatility 15x Faster: Lessons from Reverse Engineering Windows Internals on ycombinator" href="https://news.ycombinator.com/submitlink?t=Making%20Volatility%2015x%20Faster%3a%20Lessons%20from%20Reverse%20Engineering%20Windows%20Internals&u=https%3a%2f%2fdanking555.github.io%2fposts%2fmaking-volatility-15x-faster-lessons-from-reverse-engineering-windows-internals%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://danking555.github.io/>Area51</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>